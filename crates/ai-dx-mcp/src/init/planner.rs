use crate::api::{ApiError, CanonicalToolId, InitPlan, InitRequest, InitWriteFile};
use crate::config::{
    ChecksConfigV2, DuplicatesCheckConfigV2, GateConfig, LocCheckConfigV2, PluginConfig,
    PluginMeta, SupplyChainCheckConfigV2, ToolBudgetCheckConfigV2, ToolExecutionPolicyConfigV2,
};
use crate::packs::schema::{PackLockEntryV1, PacksLockV1};
use crate::packs::{load_builtin_packs, pack_matches_repo};
use std::collections::BTreeSet;
use std::path::Path;

const DEFAULT_PLUGIN_ID: &str = "default";
const DEFAULT_PLUGIN_DESC: &str = "Generated by compas.init (language packs + minimal gate wiring)";
const TOOL_IMPORT_GLOB: &str = "tools/custom/**/tool.toml";

fn api_err(code: &str, message: impl Into<String>) -> ApiError {
    ApiError {
        code: code.to_string(),
        message: message.into(),
    }
}

fn canonical_tool_ids_for_gate(
    gate: &crate::packs::schema::PackGatesV1,
    kind: crate::api::GateKind,
) -> &[CanonicalToolId] {
    // Boring default: if a pack defines only `ci_fast`, treat `ci` and `flagship` as `ci_fast`.
    // This keeps pack.toml minimal while still generating meaningful gates out of the box.
    match kind {
        crate::api::GateKind::CiFast => &gate.ci_fast,
        crate::api::GateKind::Ci => {
            if gate.ci.is_empty() {
                &gate.ci_fast
            } else {
                &gate.ci
            }
        }
        crate::api::GateKind::Flagship => {
            if gate.flagship.is_empty() {
                if gate.ci.is_empty() {
                    &gate.ci_fast
                } else {
                    &gate.ci
                }
            } else {
                &gate.flagship
            }
        }
    }
}

fn resolve_canonical_tool_ids(
    cfg: &crate::api::CanonicalToolsConfig,
    id: CanonicalToolId,
) -> &[String] {
    match id {
        CanonicalToolId::Build => &cfg.build,
        CanonicalToolId::Test => &cfg.test,
        CanonicalToolId::Lint => &cfg.lint,
        CanonicalToolId::Fmt => &cfg.fmt,
        CanonicalToolId::Docs => &cfg.docs,
    }
}

fn resolve_gate_tools_for_packs(
    packs: &[crate::packs::schema::PackManifestV1],
    kind: crate::api::GateKind,
) -> Result<Vec<String>, ApiError> {
    let mut out: Vec<String> = vec![];
    let mut seen: BTreeSet<String> = BTreeSet::new();

    for p in packs {
        let gates = match &p.gates {
            Some(g) => g,
            None => continue,
        };
        let canonical = p.canonical_tools.as_ref().ok_or_else(|| {
            api_err(
                "init.pack_missing_canonical_tools",
                format!("pack {:?} has gates but missing canonical_tools", p.pack.id),
            )
        })?;

        for canon_id in canonical_tool_ids_for_gate(gates, kind).iter().copied() {
            for tool_id in resolve_canonical_tool_ids(canonical, canon_id) {
                if seen.insert(tool_id.clone()) {
                    out.push(tool_id.clone());
                }
            }
        }
    }

    Ok(out)
}

fn tool_toml(tool: &crate::config::ProjectTool) -> Result<String, ApiError> {
    #[derive(serde::Serialize)]
    struct ToolFile<'a> {
        tool: &'a crate::config::ProjectTool,
    }

    toml::to_string_pretty(&ToolFile { tool }).map_err(|e| {
        api_err(
            "init.serialize_tool_failed",
            format!("failed to serialize tool.toml: {e}"),
        )
    })
}

fn infer_loc_include_globs(packs: &[crate::packs::schema::PackManifestV1]) -> Vec<String> {
    let mut globs: BTreeSet<String> = BTreeSet::new();
    for p in packs {
        for lang in &p.pack.languages {
            match lang.as_str() {
                "rust" => {
                    globs.insert("**/*.rs".to_string());
                }
                "python" => {
                    globs.insert("**/*.py".to_string());
                }
                "javascript" | "typescript" => {
                    globs.insert("**/*.js".to_string());
                    globs.insert("**/*.jsx".to_string());
                    globs.insert("**/*.ts".to_string());
                    globs.insert("**/*.tsx".to_string());
                }
                "go" => {
                    globs.insert("**/*.go".to_string());
                }
                "c" | "cpp" => {
                    globs.insert("**/*.c".to_string());
                    globs.insert("**/*.h".to_string());
                    globs.insert("**/*.cc".to_string());
                    globs.insert("**/*.cpp".to_string());
                    globs.insert("**/*.cxx".to_string());
                    globs.insert("**/*.hpp".to_string());
                }
                "csharp" => {
                    globs.insert("**/*.cs".to_string());
                }
                _ => {}
            }
        }
    }
    if globs.is_empty() {
        globs.insert("src/**/*".to_string());
    }
    globs.into_iter().collect()
}

fn default_checks_for_packs(packs: &[crate::packs::schema::PackManifestV1]) -> ChecksConfigV2 {
    let loc_include = infer_loc_include_globs(packs);
    ChecksConfigV2 {
        loc: vec![LocCheckConfigV2 {
            id: "loc-main".to_string(),
            max_loc: 600,
            include_globs: loc_include.clone(),
            exclude_globs: vec![
                "**/target/**".to_string(),
                "**/node_modules/**".to_string(),
                ".git/**".to_string(),
            ],
            baseline_path: ".agents/mcp/compas/baselines/loc.json".to_string(),
        }],
        env_registry: vec![],
        boundary: vec![],
        surface: vec![],
        duplicates: vec![DuplicatesCheckConfigV2 {
            id: "duplicates-main".to_string(),
            include_globs: loc_include.clone(),
            exclude_globs: vec![
                "**/target/**".to_string(),
                "**/node_modules/**".to_string(),
                ".git/**".to_string(),
            ],
            max_file_bytes: 256 * 1024,
            allowlist_globs: vec![],
            baseline_path: ".agents/mcp/compas/baselines/duplicates.json".to_string(),
        }],
        supply_chain: vec![SupplyChainCheckConfigV2 {
            id: "supply-chain-main".to_string(),
        }],
        tool_budget: vec![ToolBudgetCheckConfigV2 {
            id: "tool-budget-main".to_string(),
            max_tools_total: 64,
            max_tools_per_plugin: 32,
            max_gate_tools_per_kind: 16,
            max_checks_total: 24,
        }],
        reuse_first: vec![],
        arch_layers: vec![],
        dead_code: vec![],
        orphan_api: vec![],
        complexity_budget: vec![],
        contract_break: vec![],
    }
}

fn plugin_toml(gate: GateConfig, checks: ChecksConfigV2) -> Result<String, ApiError> {
    let plugin = PluginConfig {
        plugin: PluginMeta {
            id: DEFAULT_PLUGIN_ID.to_string(),
            description: DEFAULT_PLUGIN_DESC.to_string(),
            tool_import_globs: vec![TOOL_IMPORT_GLOB.to_string()],
        },
        tools: vec![],
        tool_policy: ToolExecutionPolicyConfigV2::default(),
        gate: Some(gate),
        checks: Some(checks),
    };

    toml::to_string_pretty(&plugin).map_err(|e| {
        api_err(
            "init.serialize_plugin_failed",
            format!("failed to serialize plugin.toml: {e}"),
        )
    })
}

fn quality_contract_toml() -> String {
    r#"# Compas Sentinel v1 â€” quality policy contract

[quality]
min_trust_score = 60
allow_trust_drop = false
allow_coverage_drop = false
max_weighted_risk_increase = 0

[exceptions]
max_exceptions = 10
max_suppressed_ratio = 0.30
max_exception_window_days = 90

[receipt_defaults]
min_duration_ms = 500
min_stdout_bytes = 10

[governance]
mandatory_checks = ["supply_chain", "loc", "tool_budget"]
mandatory_failure_modes = []
min_failure_modes = 1

[proof]
require_witness = true

[baseline]
snapshot_path = ".agents/mcp/compas/baselines/quality_snapshot.json"
max_scope_narrowing = 0.10
"#
    .to_string()
}

fn packs_lock_toml(entries: Vec<PackLockEntryV1>) -> Result<String, ApiError> {
    let lock = PacksLockV1 {
        version: 1,
        packs: entries,
    };
    toml::to_string_pretty(&lock).map_err(|e| {
        api_err(
            "init.serialize_packs_lock_failed",
            format!("failed to serialize packs.lock: {e}"),
        )
    })
}

/// Generate an init plan (dry-run) for a repo based on detected/selected packs.
///
/// This slice intentionally does not apply the plan and does not perform any external I/O
/// (network download / vendoring).
pub(crate) fn plan_init(repo_root: &Path, req: &InitRequest) -> Result<InitPlan, ApiError> {
    if req.external_packs.as_ref().is_some_and(|v| !v.is_empty()) {
        return Err(api_err(
            "init.external_packs_unsupported",
            "external_packs are not supported in this slice (dry-run only)",
        ));
    }

    let builtin = load_builtin_packs().map_err(|e| api_err("init.load_builtin_failed", e))?;

    let mut selected_ids: Vec<String> = vec![];
    if let Some(overrides) = &req.packs {
        for p in overrides.iter().map(|s| s.trim()).filter(|s| !s.is_empty()) {
            let id = p.strip_prefix("builtin:").ok_or_else(|| {
                api_err(
                    "init.invalid_pack_ref",
                    format!("unsupported pack ref: {p:?}"),
                )
            })?;
            if !builtin.contains_key(id) {
                return Err(api_err(
                    "init.unknown_builtin_pack",
                    format!("unknown builtin pack id={id:?}"),
                ));
            }
            selected_ids.push(id.to_string());
        }
    } else {
        for (id, pack) in &builtin {
            if pack_matches_repo(repo_root, pack) {
                selected_ids.push(id.clone());
            }
        }
    }

    selected_ids.sort();
    selected_ids.dedup();

    // Universal bootstrap: when no builtin pack is detected, still scaffold compas files
    // (plugin + quality contract + empty packs.lock). Gate remains fail-closed with
    // gate.empty_sequence until project tools are wired explicitly.

    let mut packs: Vec<crate::packs::schema::PackManifestV1> =
        Vec::with_capacity(selected_ids.len());
    for id in &selected_ids {
        let m = builtin.get(id).ok_or_else(|| {
            api_err(
                "init.unknown_builtin_pack",
                format!("unknown builtin pack id={id:?}"),
            )
        })?;
        packs.push(m.clone());
    }

    // tools/custom/*/tool.toml
    let mut writes: Vec<InitWriteFile> = vec![];
    let mut seen_tool_ids: BTreeSet<String> = BTreeSet::new();
    for pack in &packs {
        for t in &pack.tools {
            if !seen_tool_ids.insert(t.tool.id.clone()) {
                return Err(api_err(
                    "init.duplicate_tool_id",
                    format!("duplicate tool id across selected packs: {:?}", t.tool.id),
                ));
            }
            let path = format!("tools/custom/{}/tool.toml", t.tool.id);
            let content_utf8 = tool_toml(&t.tool)?;
            writes.push(InitWriteFile { path, content_utf8 });
        }
    }

    // .agents/mcp/compas/packs/*/pack.toml + packs.lock
    let mut lock_entries: Vec<PackLockEntryV1> = vec![];
    for pack in &packs {
        let pack_toml = toml::to_string_pretty(pack).map_err(|e| {
            api_err(
                "init.serialize_pack_failed",
                format!("failed to serialize pack.toml for {:?}: {e}", pack.pack.id),
            )
        })?;
        writes.push(InitWriteFile {
            path: format!(".agents/mcp/compas/packs/{}/pack.toml", pack.pack.id),
            content_utf8: pack_toml,
        });
        lock_entries.push(PackLockEntryV1 {
            id: pack.pack.id.clone(),
            source: format!("builtin:{}", pack.pack.id),
            sha256: None,
            resolved_path: None,
            version: Some(pack.pack.version.clone()),
        });
    }
    lock_entries.sort_by(|a, b| a.id.cmp(&b.id));
    writes.push(InitWriteFile {
        path: ".agents/mcp/compas/packs.lock".to_string(),
        content_utf8: packs_lock_toml(lock_entries)?,
    });

    // .agents/mcp/compas/plugins/default/plugin.toml
    let gate_cfg = GateConfig {
        ci_fast: resolve_gate_tools_for_packs(&packs, crate::api::GateKind::CiFast)?,
        ci: resolve_gate_tools_for_packs(&packs, crate::api::GateKind::Ci)?,
        flagship: resolve_gate_tools_for_packs(&packs, crate::api::GateKind::Flagship)?,
    };
    writes.push(InitWriteFile {
        path: ".agents/mcp/compas/plugins/default/plugin.toml".to_string(),
        content_utf8: plugin_toml(gate_cfg, default_checks_for_packs(&packs))?,
    });

    writes.push(InitWriteFile {
        path: ".agents/mcp/compas/quality_contract.toml".to_string(),
        content_utf8: quality_contract_toml(),
    });

    writes.sort_by(|a, b| a.path.cmp(&b.path));

    Ok(InitPlan {
        writes,
        deletes: vec![],
    })
}

#[cfg(test)]
mod tests;
